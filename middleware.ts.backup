import { createServerClient } from '@supabase/ssr';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import type { CookieOptions } from '@supabase/ssr';

export async function middleware(req: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: req.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        get(name: string) {
          return req.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          req.cookies.set({
            name,
            value,
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: req.headers,
            },
          });
          response.cookies.set({
            name,
            value,
            ...options,
          });
        },
        remove(name: string, options: CookieOptions) {
          req.cookies.set({
            name,
            value: '',
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: req.headers,
            },
          });
          response.cookies.set({
            name,
            value: '',
            ...options,
          });
        },
      },
    }
  );

  // Refresh session if expired - required for Server Components
  const {
    data: { session },
  } = await supabase.auth.getSession();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const { pathname } = req.nextUrl;

  // Define public routes that don't require authentication
  const publicRoutes = [
    '/',
    '/auth/login',
    '/auth/register',
    '/auth/cleanup',
    '/riders',
    '/test-direct',
    '/test-roles',
    '/test-supabase',
    '/debug-user',
  ];

  // API routes that should be accessible
  const apiRoutes = [
    '/api/stripe/webhook',
    '/api/stripe/onboarding',
    '/api/stripe/create-account',
    '/api/stripe/create-login-link',
    '/api/stripe/create-payment-intent',
  ];

  // Check if current path is public
  const isPublicRoute = publicRoutes.some(
    route => pathname === route || pathname.startsWith(`${route}/`)
  );

  const isApiRoute = apiRoutes.some(route => pathname.startsWith(route));

  // Allow API routes to pass through
  if (isApiRoute) {
    return response;
  }

  // If user is not authenticated and trying to access protected route
  if (!session && !isPublicRoute) {
    // Don't redirect if this is a static file request (like SVG, CSS, JS)
    if (
      pathname.startsWith('/_next/') ||
      pathname.startsWith('/public/') ||
      pathname.includes('.svg') ||
      pathname.includes('.css') ||
      pathname.includes('.js') ||
      pathname.includes('.png') ||
      pathname.includes('.jpg') ||
      pathname.includes('.ico')
    ) {
      return response;
    }

    console.log('üö´ Middleware: No session found, redirecting to login');
    const redirectUrl = new URL('/auth/login', req.url);
    redirectUrl.searchParams.set('redirectTo', pathname);
    return NextResponse.redirect(redirectUrl);
  }

  // Handle case where session exists but user might be invalid
  if (session && !isPublicRoute) {
    try {
      // Validate that the user exists in our system
      const userValidation = await supabase.auth.getUser();

      if (
        userValidation.error?.message?.includes('user_not_found') ||
        userValidation.error?.code === 'user_not_found'
      ) {
        console.log(
          'üö´ Middleware: User not found in database, clearing session'
        );

        // Create response that clears cookies and redirects
        const loginUrl = new URL('/auth/login', req.url);
        loginUrl.searchParams.set('error', 'user_not_found');

        const redirectResponse = NextResponse.redirect(loginUrl);

        // Clear Supabase cookies
        redirectResponse.cookies.set('sb-access-token', '', {
          expires: new Date(0),
          path: '/',
        });
        redirectResponse.cookies.set('sb-refresh-token', '', {
          expires: new Date(0),
          path: '/',
        });

        return redirectResponse;
      }
    } catch (error) {
      console.error('‚ùå Middleware: Error validating user:', error);
      // If we can't validate the user, redirect to login
      const loginUrl = new URL('/auth/login', req.url);
      return NextResponse.redirect(loginUrl);
    }
  }

  // If user is authenticated and trying to access auth pages, redirect to dashboard
  if (
    session &&
    (pathname === '/auth/login' || pathname === '/auth/register')
  ) {
    // Get user role from metadata
    const userRole = user?.user_metadata?.role;

    if (userRole === 'rider') {
      return NextResponse.redirect(new URL('/dashboard/rider', req.url));
    } else if (userRole === 'merchant') {
      return NextResponse.redirect(new URL('/dashboard/merchant', req.url));
    } else {
      // Default fallback
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }
  }

  // If user is authenticated and accessing dashboard without specific role route
  if (session && pathname === '/dashboard') {
    const userRole = user?.user_metadata?.role;

    if (userRole === 'rider') {
      return NextResponse.redirect(new URL('/dashboard/rider', req.url));
    } else if (userRole === 'merchant') {
      return NextResponse.redirect(new URL('/dashboard/merchant', req.url));
    }
  }

  // Role-based access control for dashboard routes
  if (session && pathname.startsWith('/dashboard/')) {
    const userRole = user?.user_metadata?.role;

    if (pathname.includes('/rider') && userRole !== 'rider') {
      // Rider trying to access merchant dashboard
      return NextResponse.redirect(new URL('/dashboard/merchant', req.url));
    }

    if (pathname.includes('/merchant') && userRole !== 'merchant') {
      // Merchant trying to access rider dashboard
      return NextResponse.redirect(new URL('/dashboard/rider', req.url));
    }
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|public/).*)',
  ],
};
